import t from"openai";import{OpenAIClient as e,OpenAIKeyCredential as a}from"@azure/openai";async function s(t,e,a,s){let n=null;if(!0===s&&"0"!=e)try{n=await t.beta.threads.retrieve(e)}catch(t){console.log(t),console.log(t.status),console.log(`Error status ${t.status}. Unable to retrieve the thread ${thread_id}`)}return null==n&&(console.log("Creating new thread"),n=await t.beta.threads.create({metadata:{assistanceName:a.name}}),a=await t.beta.assistants.update(a.id,{metadata:{thread_id:n.id,lastRunId:"0"}})),{thread:n,assistant:a}}async function n(n){let{provider:i,assistantName:o,credentials:r}=n,l="openai"===i?r.openaiKey:r.azureaiKey,d=r.azureaiEndpoint;console.log(l);let u="openai"===i?new t({apiKey:l,dangerouslyAllowBrowser:!0}):new e(d,new a(l)),c=(await u.beta.assistants.list({order:"desc",limit:"100"})).data.find(t=>{if(t.name===o)return t}),h=null==c?await async function(t,e){let{assistantName:a,instructions:n,model:i,specs:o,reuseThread:r}=e,l={name:a,instructions:n,model:i,metadata:{thread_id:"0",lastRunId:"0"}};null!=o.tools&&(l.tools=o.tools);let d=await t.beta.assistants.create(l);console.log("-----------------------------------"),console.log("New Assistant: ",a,d.id);let u=await s(t,e.threadid,d,r);return console.log("Thread ID: ",u.thread.id),console.log("-----------------------------------"),{openai:t,assistant:u.assistant,thread:u.thread,threadid:u.thread.id,specs:o}}(u,n):await async function(t,e,a){let{reuseThread:n}=a;console.log("Using Existing Assistant: ",e.name,e.id);let i=e.metadata.thread_id;"0"!==a.threadid&&(i=a.threadid),console.log("Associated thread_id: ",i);let o=await s(t,i,e,n);return{openai:t,assistant:o.assistant,thread:o.thread,threadid:o.thread.id,specs:a.specs}}(u,c,n);return h}async function i(t,e){let{openai:a,thread:s}=t;const n=await a.beta.threads.messages.list(s.id,{limit:e});let i=[],o=n.data;for(let t=0;t<n.data.length;t++){let e=o[t].content[0];if("assistant"!==o[t].role)break;i.push({id:o[t].id,role:o[t].role,type:e.type,content:e[e.type].value})}return i.length>1&&(i=i.reverse()),i}async function o(t,e,a){let{openai:s,assistant:n}=a,i=null,o=null;function r(t){return new Promise(e=>setTimeout(e,t))}do{o=await s.beta.threads.runs.retrieve(t.id,e.id),console.log("-------------------",o.status),"queued"!==o.status&&"in_progress"!==o.status&&"cancelling"!==o.status?i=o.status:await r(2e3)}while(null===i);let l=await s.beta.assistants.update(n.id,{metadata:{thread_id:t.id,lastRunId:e.id}});return a.assistant=l,o}async function r(t,e,a,s){let{openai:n,assistant:r,thread:l}=e,d=null,u=null;try{u=await n.beta.threads.messages.create(l.id,{role:"user",content:t})}catch(t){return console.log(`status = ${t.status}. Unable to add the prompt to the thread`),console.log("will try to cancel the last run"),{status:t.status,message:t}}let c={assistant_id:r.id,instructions:null!=s?s:""};d=await n.beta.threads.runs.create(l.id,c);let h=await o(l,d,e);return"completed"===h.status?await i(e,1):"requires_action"===h.status?(await async function(t,e,a,s,n){let{openai:i,specs:r}=s,{functionList:l}=r,d=t.required_action.submit_tool_outputs.tool_calls,u=[];for(let t of d){let e=t.function.name;console.log("Requested function: ",e);let a=JSON.parse(t.function.arguments),i=await l[e](a,n,s);u.push({tool_call_id:t.id,output:JSON.stringify(i)})}let c=await i.beta.threads.runs.submitToolOutputs(e.id,a.id,{tool_outputs:u});return await o(e,c,s)}(h,l,d,e,a),await i(e,5)):{runStatus:h.status}}async function l(t,e){return console.log("in closeAssistant"),!0}async function d(t,e){let{openai:a,thread:s}=t;return(await a.beta.threads.messages.list(s.id,{limit:e})).data.map(t=>{let e=t.content[0];return{id:t.id,role:t.role,type:e.type,content:e[e.type].value}})}export{l as closeAssistant,i as getLatestMessage,d as getMessages,r as runAssistant,n as setupAssistant};
//# sourceMappingURL=index.modern.js.map
